"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[5541],{6114:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"papers/why models hallucinate","title":"Paper - Why Language Models Hallucinate","description":"Source//arxiv.org/html/2509.04664v1","source":"@site/notes/papers/why models hallucinate.md","sourceDirName":"papers","slug":"/papers/why models hallucinate","permalink":"/notes/papers/why models hallucinate","draft":false,"unlisted":false,"editUrl":"https://github.com/p-s-vishnu/p-s-vishnu.github.io/tree/main/notes/papers/why models hallucinate.md","tags":[{"inline":true,"label":"math","permalink":"/notes/tags/math"},{"inline":true,"label":"llm","permalink":"/notes/tags/llm"}],"version":"current","frontMatter":{"title":"Paper - Why Language Models Hallucinate","tags":["math","llm"]},"sidebar":"tutorialSidebar","previous":{"title":"Python","permalink":"/notes/Python"}}');var s=t(4848),r=t(8453);const a={title:"Paper - Why Language Models Hallucinate",tags:["math","llm"]},o=void 0,l={},c=[{value:"TLDR",id:"tldr",level:3},{value:"Technical Points to Know",id:"technical-points-to-know",level:3},{value:"Important Sections",id:"important-sections",level:3},{value:"<strong>Pretraining Errors (Section 3)</strong>",id:"pretraining-errors-section-3",level:4},{value:"<strong>Why Hallucinations Survive Post-Training (Section 4)</strong>",id:"why-hallucinations-survive-post-training-section-4",level:4},{value:"<strong>Proposed Mitigation: Explicit Confidence Targets (Section 4.2)</strong>",id:"proposed-mitigation-explicit-confidence-targets-section-42",level:4}];function h(e){const n={a:"a",blockquote:"blockquote",code:"code",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Source: Why Language Models Hallucinate ",(0,s.jsx)(n.a,{href:"https://arxiv.org/html/2509.04664v1",children:"https://arxiv.org/html/2509.04664v1"})]}),"\n",(0,s.jsx)(n.h3,{id:"tldr",children:"TLDR"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Language models (LLMs) hallucinate because they are trained and evaluated in a way that rewards guessing over admitting uncertainty."}),"\n",(0,s.jsx)(n.li,{children:"The paper presents a theoretical argument showing that hallucinations are a natural statistical outcome of the pre-training process, not just a bug."}),"\n",(0,s.jsx)(n.li,{children:'The core reason they persist is that most industry benchmarks use binary (right/wrong) scoring, which incentivises models to make a confident guess rather than say "I don\'t know."'}),"\n",(0,s.jsx)(n.li,{children:"The authors propose a socio-technical solution: modify existing evaluation benchmarks to include explicit penalties for incorrect answers, thereby encouraging models to only respond when genuinely confident."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"technical-points-to-know",children:"Technical Points to Know"}),"\n",(0,s.jsx)(n.p,{children:"The paper introduces several key technical concepts to formalise the origins of hallucinations:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Reduction to Binary Classification:"})," The paper's central technical innovation is reducing the unsupervised problem of generative error (hallucination) to a supervised binary classification problem, which they term ",(0,s.jsx)(n.strong,{children:'"Is-It-Valid" (IIV)'}),". This allows the application of decades of statistical learning theory to LLM errors."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Any LLM ",(0,s.jsx)(n.code,{children:"p\u0302"})," can be converted into a classifier ",(0,s.jsx)(n.code,{children:"f\u0302"})," by thresholding its probability assignment: an output ",(0,s.jsx)(n.code,{children:"x"})," is classified as valid ('+') if ",(0,s.jsx)(n.code,{children:"p\u0302(x)"})," is above a certain value, and an error ('-') otherwise."]}),"\n",(0,s.jsxs)(n.li,{children:["This leads to the core inequality: ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"err \u2265 2 * err_iiv - (bias terms)"})}),", where ",(0,s.jsx)(n.code,{children:"err"})," is the model's generative error rate and ",(0,s.jsx)(n.code,{children:"err_iiv"})," is its misclassification rate on the IIV problem. This mathematically links generative errors to classification errors."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Calibration and Cross-Entropy:"}),' The standard cross-entropy loss objective used in pretraining naturally produces models that are "calibrated" in a specific sense. The paper shows that for such calibrated models, errors are a statistical necessity. A model that never errs (e.g., by always saying "I don\'t know") would have to be poorly calibrated with respect to the cross-entropy objective, meaning it would not be a local minimum for the training loss.']}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arbitrary-Fact Hallucinations and Singletons:"})," For facts that have no learnable pattern (e.g., a person's birthday), the model's ability to recall them depends on their frequency in the training data. The paper connects the hallucination rate to the \"singleton rate\" (",(0,s.jsx)(n.code,{children:"sr"}),"), which is the fraction of training prompts that appear only once."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Theorem 2"})," states that for these types of facts, the expected error rate is approximately equal to the singleton rate (",(0,s.jsx)(n.code,{children:"err \u2248 sr"}),"). If 20% of birthday facts in the training data are singletons, a base model is expected to hallucinate on at least 20% of birthday-related queries."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Poor Models and Agnostic Learning:"})," Hallucinations can also arise when a model's architecture is fundamentally unsuited for a task. The paper connects this to the concept of ",(0,s.jsx)(n.code,{children:"opt(G)"})," from agnostic learning\u2014the best possible error rate achievable by any classifier within a given family ",(0,s.jsx)(n.code,{children:"G"}),". If ",(0,s.jsx)(n.code,{children:"opt(G)"})," is high for a certain task, then any model from that family is guaranteed to have a high error rate."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"An example is a token-based LLM being asked to count characters, a task for which its representation may be ill-suited, whereas a model with a reasoning mechanism might perform better."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"important-sections",children:"Important Sections"}),"\n",(0,s.jsx)(n.h4,{id:"pretraining-errors-section-3",children:(0,s.jsx)(n.strong,{children:"Pretraining Errors (Section 3)"})}),"\n",(0,s.jsx)(n.p,{children:"This section provides the theoretical foundation for why base models hallucinate before any fine-tuning."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Key Insight:"})," Hallucinations are not a mysterious emergent property but a predictable consequence of statistical density estimation. Even with perfectly clean training data, the pressure to create a good probabilistic model of the data forces the model to generate errors on less-frequent or unlearnable patterns. The reduction to the IIV classification problem is the main tool used here to demonstrate that if a concept is hard to classify, it will be hard to generate correctly. The analysis shows that for a model to avoid errors entirely, it would have to perform poorly on the fundamental pretraining objective of density estimation."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"why-hallucinations-survive-post-training-section-4",children:(0,s.jsx)(n.strong,{children:"Why Hallucinations Survive Post-Training (Section 4)"})}),"\n",(0,s.jsx)(n.p,{children:"This section shifts from theoretical origins to a practical, socio-technical explanation for why methods like RLHF have not eliminated hallucinations."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Key Insight:"}),' The evaluation ecosystem is the primary culprit. Most influential benchmarks (e.g., MMLU-Pro, SWE-bench, MATH) use binary grading where answers are simply right or wrong. Under this scheme, a model that guesses when uncertain has a higher expected score than one that abstains by saying "I don\'t know." Since models are optimised to climb these leaderboards, they are implicitly trained to hallucinate [1]. The paper describes this as an "epidemic" of penalising uncertainty [1].']}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"proposed-mitigation-explicit-confidence-targets-section-42",children:(0,s.jsx)(n.strong,{children:"Proposed Mitigation: Explicit Confidence Targets (Section 4.2)"})}),"\n",(0,s.jsx)(n.p,{children:"This section offers a concrete, actionable solution aimed at the entire ML community rather than a specific model-based fix."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Key Insight:"})," To build more trustworthy models, the rules of the game must change. Instead of creating more specialised (and often ignored) hallucination benchmarks, the authors propose modifying the primary benchmarks themselves. They suggest adding instructions to prompts that specify a confidence threshold ",(0,s.jsx)(n.code,{children:"t"})," and an associated penalty for wrong answers. For example:"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"\"Answer only if you are >90% confident. Correct answers get 1 point, 'I don't know' gets 0 points, and incorrect answers get -9 points.\""}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:['This makes the optimal strategy for the model one of "behavioural calibration"\u2014it should only answer if its internal confidence is higher than the stated threshold ',(0,s.jsx)(n.code,{children:"t"}),". By making the threshold explicit in the prompt, a single model can learn to perform optimally across all settings, steering the field towards models that are more honest about their uncertainty [1]."]}),"\n"]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var i=t(6540);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);